package com.application.common.spring.swagger;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import io.swagger.v3.core.converter.AnnotatedType;
import io.swagger.v3.core.converter.ModelConverters;
import io.swagger.v3.core.converter.ResolvedSchema;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.media.Schema;
import lombok.extern.slf4j.Slf4j;

/**
 * Generates named schemas for data types (T) using SpringDoc reflection.
 * 
 * This component is responsible for creating the base T schemas that wrapper types
 * will reference, ensuring complete type information through SpringDoc's ModelConverters.
 */
@Slf4j
public class DataTypeSchemaGenerator {

    /**
     * Generate named schemas for each unique T type using SpringDoc reflection
     * 
     * For each unique data type discovered in wrapper types:
     * 1. Uses SpringDoc ModelConverters for complete type introspection
     * 2. Creates named schema in components/schemas (e.g., "UserDto")
     * 3. Includes all referenced nested schemas
     * 
     * @param wrapperTypes All discovered wrapper types
     * @param openApi OpenAPI spec to add schemas to
     * @param registry Registry to track processed types
     */
    public void generateDataTypeSchemas(Set<WrapperTypeInfo> wrapperTypes, OpenAPI openApi, WrapperTypeRegistry registry) {
        @SuppressWarnings("rawtypes")
        Map<String, Schema> schemas = openApi.getComponents().getSchemas();
        
        // Extract all unique T types from wrapper declarations
        Set<String> uniqueDataTypes = extractUniqueDataTypes(wrapperTypes);
        
        // ðŸŽ¯ TRACE SPECIFICO PER AuthResponseDTO
        for (String dataType : uniqueDataTypes) {
            if (dataType.contains("AuthResponseDTO")) {
                log.warn("ðŸŽ¯ FASE3-AuthResponseDTO: FOUND in uniqueDataTypes! dataType={}", dataType);
            }
        }
        
        // System.out.println("DataTypeSchemaGenerator: Generating schemas for " + uniqueDataTypes.size() + " unique data types");
        
        // Generate SpringDoc schema for each unique T type
        for (String dataClassName : uniqueDataTypes) {
            // ðŸŽ¯ TRACE SPECIFICO PER AuthResponseDTO  
            if (dataClassName.contains("AuthResponseDTO")) {
                log.warn("ðŸŽ¯ FASE3-AuthResponseDTO: PROCESSING dataClass={}", dataClassName);
            }
            generateSingleDataTypeSchema(dataClassName, schemas, registry);
        }
    }

    /**
     * Extract unique data type class names from wrapper types
     */
    private Set<String> extractUniqueDataTypes(Set<WrapperTypeInfo> wrapperTypes) {
        Set<String> uniqueDataTypes = new HashSet<>();
        for (WrapperTypeInfo wrapperInfo : wrapperTypes) {
            if (!isPrimitiveJavaType(wrapperInfo.dataClassName)) {
                uniqueDataTypes.add(wrapperInfo.dataClassName);
            }
        }
        return uniqueDataTypes;
    }

    /**
     * Generate schema for a single data type using SpringDoc
     */
    private void generateSingleDataTypeSchema(String dataClassName, @SuppressWarnings("rawtypes") Map<String, Schema> schemas, WrapperTypeRegistry registry) {
        String simpleClassName = dataClassName.substring(dataClassName.lastIndexOf('.') + 1);
        
        if (!schemas.containsKey(simpleClassName)) {
            // Use SpringDoc's reflection to generate complete schema
            Schema<?> dataTypeSchema = createSchemaUsingSpringDoc(dataClassName);
            
            if (dataTypeSchema != null) {
                schemas.put(simpleClassName, dataTypeSchema);
                registry.registerDataType(dataClassName);
                // System.out.println("DataTypeSchemaGenerator: Generated SpringDoc schema for " + simpleClassName);
                
                // ðŸŽ¯ TRACE SPECIFICO PER AuthResponseDTO
                if (dataClassName.contains("AuthResponseDTO")) {
                    log.warn("ðŸŽ¯ FASE3-AuthResponseDTO: SCHEMA GENERATED! simpleClassName={}", simpleClassName);
                }
                
                // SpringDoc may generate additional schemas for nested types
                addReferencedSchemas(dataClassName, schemas);
            } else {
                // Fallback when SpringDoc reflection fails
                createFallbackSchema(simpleClassName, dataClassName, schemas, registry);
            }
        } else {
            System.out.println("DataTypeSchemaGenerator: Schema " + simpleClassName + " already exists, skipping");
        }
    }

    /**
     * Add any referenced schemas generated by SpringDoc
     */
    private void addReferencedSchemas(String dataClassName, @SuppressWarnings("rawtypes") Map<String, Schema> schemas) {
        Map<String, Schema<?>> additionalSchemas = getAdditionalSchemasFromSpringDoc(dataClassName);
        if (additionalSchemas != null) {
            for (Map.Entry<String, Schema<?>> entry : additionalSchemas.entrySet()) {
                if (!schemas.containsKey(entry.getKey())) {
                    schemas.put(entry.getKey(), entry.getValue());
                    System.out.println("DataTypeSchemaGenerator: Added referenced schema " + entry.getKey());
                }
            }
        }
    }

    /**
     * Create fallback schema when SpringDoc reflection fails
     */
    private void createFallbackSchema(String simpleClassName, String dataClassName, @SuppressWarnings("rawtypes") Map<String, Schema> schemas, WrapperTypeRegistry registry) {
        Schema<?> fallbackSchema = new Schema<>();
        fallbackSchema.setType("object");
        fallbackSchema.setDescription("Auto-generated schema for " + simpleClassName);
        schemas.put(simpleClassName, fallbackSchema);
        registry.registerDataType(dataClassName);
        System.out.println("DataTypeSchemaGenerator: Created fallback schema for " + simpleClassName);
    }

    /**
     * Create schema using SpringDoc ModelConverters for complete type information
     */
    private Schema<?> createSchemaUsingSpringDoc(String fullClassName) {
        try {
            Class<?> clazz = Class.forName(fullClassName);
            
            // Use SpringDoc ModelConverters for complete type introspection
            AnnotatedType annotatedType = new AnnotatedType(clazz);
            ResolvedSchema resolvedSchema = ModelConverters.getInstance().resolveAsResolvedSchema(annotatedType);
            
            if (resolvedSchema != null && resolvedSchema.schema != null) {
                System.out.println("DataTypeSchemaGenerator: SpringDoc generated schema for " + fullClassName);
                return resolvedSchema.schema;
            }
            
        } catch (ClassNotFoundException e) {
            System.err.println("DataTypeSchemaGenerator: Class not found: " + fullClassName);
        } catch (Exception e) {
            System.err.println("DataTypeSchemaGenerator: Error creating schema for " + fullClassName + ": " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Get all additional schemas generated by SpringDoc for referenced types
     */
    private Map<String, Schema<?>> getAdditionalSchemasFromSpringDoc(String fullClassName) {
        try {
            Class<?> clazz = Class.forName(fullClassName);
            
            // Use SpringDoc ModelConverters to get ALL related schemas
            AnnotatedType annotatedType = new AnnotatedType(clazz);
            ResolvedSchema resolvedSchema = ModelConverters.getInstance().resolveAsResolvedSchema(annotatedType);
            
            if (resolvedSchema != null && resolvedSchema.referencedSchemas != null) {
                // Convert to compatible map type
                Map<String, Schema<?>> result = new HashMap<>();
                for (Map.Entry<String, ?> entry : resolvedSchema.referencedSchemas.entrySet()) {
                    @SuppressWarnings("unchecked")
                    Schema<Object> schema = (Schema<Object>) entry.getValue();
                    result.put(entry.getKey(), schema);
                }
                System.out.println("DataTypeSchemaGenerator: Found " + result.size() + " additional schemas for " + fullClassName);
                return result;
            }
            
        } catch (ClassNotFoundException e) {
            System.err.println("DataTypeSchemaGenerator: Class not found for additional schemas: " + fullClassName);
        } catch (Exception e) {
            System.err.println("DataTypeSchemaGenerator: Error getting additional schemas for " + fullClassName + ": " + e.getMessage());
        }
        
        return null;
    }

    /**
     * Check if a class name represents a primitive Java type
     */
    private boolean isPrimitiveJavaType(String fullClassName) {
        return fullClassName.equals("java.lang.String") ||
               fullClassName.equals("java.lang.Long") ||
               fullClassName.equals("java.lang.Integer") ||
               fullClassName.equals("java.lang.Boolean") ||
               fullClassName.equals("java.lang.Double") ||
               fullClassName.equals("java.lang.Float") ||
               fullClassName.equals("java.math.BigDecimal") ||
               fullClassName.equals("java.time.LocalDate") ||
               fullClassName.equals("java.time.LocalDateTime") ||
               fullClassName.equals("java.time.Instant") ||
               fullClassName.equals("java.util.Date") ||
               fullClassName.equals("long") ||
               fullClassName.equals("int") ||
               fullClassName.equals("boolean") ||
               fullClassName.equals("double") ||
               fullClassName.equals("float") ||
               (fullClassName.startsWith("java.lang.") && isPrimitiveWrapper(fullClassName)) ||
               (fullClassName.startsWith("java.time.") && !fullClassName.contains("$"));
    }
    
    private boolean isPrimitiveWrapper(String className) {
        String simpleName = className.substring(className.lastIndexOf('.') + 1);
        return simpleName.equals("String") ||
               simpleName.equals("Integer") ||
               simpleName.equals("Long") ||
               simpleName.equals("Double") ||
               simpleName.equals("Float") ||
               simpleName.equals("Boolean") ||
               simpleName.equals("Byte") ||
               simpleName.equals("Short") ||
               simpleName.equals("Character");
    }
}
