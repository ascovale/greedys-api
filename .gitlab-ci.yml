# Pipeline corretta per API con generator v1.0.0-SNAPSHOT
variables:
  TAG_LATEST: ${CI_REGISTRY_IMAGE}:latest
  TAG_COMMIT: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA}
  DART_REPO: https://gitlab.com/GreedysGroup/greedys_api_dart_lib.git
  API_DOCS_BASE: "http://api.greedys.it:8080/v3/api-docs"
  WRAPPERS_ENDPOINT: "http://api.greedys.it:8080/api/internal/response-wrapper-catalog"
  API_GROUPS: "restaurant admin customer"

stages:
  - build
  - deploy
  - publish

cache:
  paths:
    - .m2/repository
    - node_modules/
    - tools/

build:
  image: docker:24.0.5
  stage: build
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_BUILDKIT: "1"
  script:
    - echo "Logging into Docker registry..."
    - echo $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY
    - echo "Building and tagging Docker image..."
    - |
      for i in 1 2 3; do \
        docker build --pull --progress=plain -t $TAG_LATEST --build-arg SPRING_PROFILES_ACTIVE="docker" . && break || { echo "docker build failed (attempt $i/3), retrying in 10s"; sleep 10; }; \
      done
    - echo "Tagging Docker image with commit tag..."
    - docker tag $TAG_LATEST $TAG_COMMIT
    - echo "Pushing Docker images..."
    - docker push $TAG_LATEST
    - docker push $TAG_COMMIT
  only:
    - main
  after_script:
    - echo "Cleaning up Docker resources..."
    - docker system prune -f

deploy:
  image: alpine:3.18
  stage: deploy
  before_script:
    - apk add --no-cache openssh-client openssh-keygen
    - mkdir -p deploy
    - cp "$ID_RSA" deploy/id_key
    - tr -d '\r' < deploy/id_key > deploy/id_key.clean && mv deploy/id_key.clean deploy/id_key
    - chmod 600 deploy/id_key
    - mkdir -p ~/.ssh && ssh-keyscan -H "$SERVER_IP" >> ~/.ssh/known_hosts
    - echo "== Key sanity ==" && head -1 deploy/id_key && tail -1 deploy/id_key
    - ssh-keygen -lf deploy/id_key
    - ssh-keygen -y -f deploy/id_key > deploy/id_key.pub
    - |
      echo "== Match con authorized_keys su deployer =="
      ssh -o BatchMode=yes -o IdentitiesOnly=yes -i deploy/id_key deployer@"$SERVER_IP" \
        "grep -F -x -q \"$(cat deploy/id_key.pub)\" ~/.ssh/authorized_keys && echo MATCH || echo NO_MATCH"
  script:
    - ssh -o IdentitiesOnly=yes -i deploy/id_key deployer@"$SERVER_IP" 'mkdir -p ~/greedys_api/'
    - scp -o IdentitiesOnly=yes -i deploy/id_key docker-compose.yml deploy.sh deployer@"$SERVER_IP":~/greedys_api/
    - printf '%s' "$CI_JOB_TOKEN" | ssh -o IdentitiesOnly=yes -i deploy/id_key deployer@"$SERVER_IP" "docker login -u gitlab-ci-token --password-stdin $CI_REGISTRY"
    - ssh -o IdentitiesOnly=yes -i deploy/id_key deployer@"$SERVER_IP" 'cd ~/greedys_api/ && chmod +x ./deploy.sh && ./deploy.sh'
  only: [main]

publish:
  image: openjdk:17-slim
  stage: publish
  before_script:
    - echo "Setup ambiente per generazione Dart..."
    - apt-get update && apt-get install -y curl git unzip jq
    
    # SCARICA JAR STANDALONE E TEMPLATES DALLA VERSIONE 1.0.0-SNAPSHOT
    - echo "üì¶ Scarico JAR standalone custom e templates dal Package Registry v1.0.0-SNAPSHOT..."
    - mkdir -p tools generator/templates
    - |
      # Ricerca dinamica URL corretto per versione 1.0.0-SNAPSHOT con timestamp
      echo "ÔøΩ Ricerca versione 1.0.0-SNAPSHOT con timestamp corretto..."
      
      # Query Package Registry per trovare l'URL esatto con timestamp
      PACKAGES_JSON=$(curl -s --header "Private-Token:$PAT" \
        "https://gitlab.com/api/v4/projects/greedysgroup%2Fgreedys_generator/packages?package_type=maven")
      
      echo "üìã Packages trovati: $(echo "$PACKAGES_JSON" | jq -r 'length') packages"
      
      # Trova il package org/openapitools/custom/custom-dart-codegen con versione 1.0.0-SNAPSHOT pi√π recente
      SNAPSHOT_PACKAGE_ID=$(echo "$PACKAGES_JSON" | jq -r '.[] | select(.name == "org/openapitools/custom/custom-dart-codegen" and (.version | contains("1.0.0-SNAPSHOT"))) | .id' | head -1)
      
      if [ -z "$SNAPSHOT_PACKAGE_ID" ]; then
        echo "‚ùå ERRORE: Package 1.0.0-SNAPSHOT non trovato"
        echo "üìã Versioni disponibili:"
        echo "$PACKAGES_JSON" | jq -r '.[] | .version' | head -10
        exit 1
      fi
      
      echo "üì¶ Package ID trovato: $SNAPSHOT_PACKAGE_ID"
      
      # Ottieni i file del package
      PACKAGE_FILES=$(curl -s --header "Private-Token:$PAT" \
        "https://gitlab.com/api/v4/projects/greedysgroup%2Fgreedys_generator/packages/$SNAPSHOT_PACKAGE_ID/package_files")
      
      # Trova il JAR standalone (quello pi√π grande, ~31MB) - dinamicamente
      JAR_FILE_INFO=$(echo "$PACKAGE_FILES" | jq -r '.[] | select(.file_name | endswith("-standalone.jar")) | select(.size > 30000000) | .file_name')
      
      if [ -z "$JAR_FILE_INFO" ]; then
        echo "‚ùå ERRORE: JAR standalone non trovato"
        echo "üìã Files disponibili:"
        echo "$PACKAGE_FILES" | jq -r '.[] | .file_name + " (" + (.size | tostring) + " bytes)"'
        exit 1
      fi
      
      echo "üîΩ Download JAR standalone: $JAR_FILE_INFO"
      # Usa l'endpoint Maven Registry per scaricare il file
      curl -s --header "Private-Token:$PAT" "https://gitlab.com/api/v4/projects/greedysgroup%2Fgreedys_generator/packages/maven/org/openapitools/custom/custom-dart-codegen/1.0.0-SNAPSHOT/$JAR_FILE_INFO" -o "tools/custom-generator.jar"
      
      # Controlla dimensione JAR
      echo "üìä JAR scaricato - dimensione: $(stat -c%s tools/custom-generator.jar) bytes"
      if [ $(stat -c%s "tools/custom-generator.jar") -lt 1000000 ]; then
        echo "‚ùå JAR troppo piccolo (dovrebbe essere ~31MB), contenuto errore:"
        cat tools/custom-generator.jar
        
        # üÜï DEBUG DETTAGLIATO DEL JAR
        echo "üîç Analisi dettagliata del JAR:"
        echo "   File type: $(file tools/custom-generator.jar)"
        echo "   Verifica ZIP structure:"
        unzip -l tools/custom-generator.jar | head -10 || echo "‚ùå Struttura JAR non valida"
        echo "   Controllo MANIFEST.MF:"
        unzip -p tools/custom-generator.jar META-INF/MANIFEST.MF | head -10 || echo "‚ùå MANIFEST.MF non trovato"
        echo "   Test esecuzione JAR:"
        java -jar tools/custom-generator.jar --help 2>&1 | head -5 || echo "‚ùå JAR non eseguibile"
        
        exit 1
      else
        echo "‚úÖ JAR standalone dimensione OK ($(stat -c%s tools/custom-generator.jar) bytes)"
      fi
      
      # Trova il templates ZIP usando l'API dinamica
      TEMPLATES_FILE_INFO=$(echo "$PACKAGE_FILES" | jq -r '.[] | select(.file_name | endswith("-templates.zip")) | .file_name')
      
      if [ -z "$TEMPLATES_FILE_INFO" ]; then
        echo "‚ùå ERRORE: Templates ZIP non trovato"
        echo "üìã Files disponibili:"
        echo "$PACKAGE_FILES" | jq -r '.[] | .file_name + " (" + (.size | tostring) + " bytes)"'
        exit 1
      fi
      
      echo "üîΩ Download templates ZIP: $TEMPLATES_FILE_INFO"
      # Usa l'endpoint Maven Registry per scaricare il file
      curl -s --header "Private-Token:$PAT" "https://gitlab.com/api/v4/projects/greedysgroup%2Fgreedys_generator/packages/maven/org/openapitools/custom/custom-dart-codegen/1.0.0-SNAPSHOT/$TEMPLATES_FILE_INFO" -o "templates.zip"
      
      # Controlla dimensione Templates ZIP
      echo "üìä Templates ZIP - dimensione: $(stat -c%s templates.zip) bytes"
      if [ $(stat -c%s "templates.zip") -lt 1000 ]; then
        echo "‚ùå Templates ZIP troppo piccolo, contenuto errore:"
        cat templates.zip
        exit 1
      else
        echo "‚úÖ Templates ZIP dimensione OK ($(stat -c%s templates.zip) bytes)"
      fi
      
      # Estrai templates
      if [ -f "templates.zip" ] && [ -s "templates.zip" ]; then
        unzip -q templates.zip -d generator/templates/
        echo "‚úÖ Templates estratti: $(find generator/templates -name '*.mustache' | wc -l) files"
      else
        echo "‚ùå ERRORE: Templates ZIP non valido"
        exit 1
      fi
      
      # üÜï SCARICA IL FILE .openapi-generator-ignore DAL PACKAGE REGISTRY
      echo "üîΩ Scarico file .openapi-generator-ignore dal Package Registry..."
      IGNORE_FILE_INFO=$(echo "$PACKAGE_FILES" | jq -r '.[] | select(.file_name | endswith("-openapi-generator.ignore")) | .file_name')
      
      if [ -n "$IGNORE_FILE_INFO" ]; then
        echo "üì¶ File ignore trovato: $IGNORE_FILE_INFO"
        curl -s --header "Private-Token:$PAT" "https://gitlab.com/api/v4/projects/greedysgroup%2Fgreedys_generator/packages/maven/org/openapitools/custom/custom-dart-codegen/1.0.0-SNAPSHOT/$IGNORE_FILE_INFO" -o "generator/templates/.openapi-generator-ignore"
        
        if [ -f "generator/templates/.openapi-generator-ignore" ] && [ -s "generator/templates/.openapi-generator-ignore" ]; then
          echo "‚úÖ File ignore scaricato: $(stat -c%s generator/templates/.openapi-generator-ignore) bytes"
          echo "üìã Contenuto ignore file (prime righe):"
          head -5 "generator/templates/.openapi-generator-ignore" 2>/dev/null | sed 's/^/   /' || echo "   File vuoto"
        else
          echo "‚ö†Ô∏è File ignore scaricato ma vuoto, creer√≤ fallback"
        fi
      else
        echo "‚ö†Ô∏è File .openapi-generator-ignore non trovato nel Package Registry"
        echo "üìã Files disponibili:"
        echo "$PACKAGE_FILES" | jq -r '.[] | .file_name' | grep -E "(ignore|template)" || echo "   Nessun file ignore/template trovato"
      fi
      
      # Verifica che il JAR standalone sia eseguibile
      echo "üß™ Verifica JAR standalone eseguibile..."
      
      # Debug: Mostra Main-Class dal MANIFEST.MF
      echo "üîç Main-Class nel MANIFEST.MF:"
      unzip -p "tools/custom-generator.jar" META-INF/MANIFEST.MF | grep "Main-Class" || echo "   Main-Class non trovato"
      
      if java -jar "tools/custom-generator.jar" version >/dev/null 2>&1; then
        echo "‚úÖ JAR standalone funzionante"
      elif java -jar "tools/custom-generator.jar" help >/dev/null 2>&1; then
        echo "‚úÖ JAR standalone funzionante"  
      elif java -jar "tools/custom-generator.jar" list >/dev/null 2>&1; then
        echo "‚úÖ JAR standalone funzionante"
      else
        echo "‚ö†Ô∏è AVVISO: Test esecuzione JAR fallito, procedo comunque..."
        echo "   Output test help:"
        java -jar "tools/custom-generator.jar" help 2>&1 | head -5 || echo "   Comando help fallito"
        echo "   Output test senza parametri:"
        java -jar "tools/custom-generator.jar" 2>&1 | head -5 || echo "   Comando senza parametri fallito"
      fi
      
    # Setup GIT con PAT
    - echo "echo \$PAT" > /tmp/git-askpass.sh
    - chmod +x /tmp/git-askpass.sh
    - export GIT_ASKPASS=/tmp/git-askpass.sh
    
    # Salva il path assoluto del JAR prima di cambiare directory
    - export CUSTOM_JAR="$(pwd)/tools/custom-generator.jar"
    - echo "JAR configurato:" $CUSTOM_JAR "($(stat -c%s $CUSTOM_JAR) bytes)"

    - echo "Clono repo Dart API..."
    - git clone https://gitlab.com/GreedysGroup/greedys_api_dart_lib.git
    - cd greedys_api_dart_lib
    - git config user.email "ci-bot@greedys.com"
    - git config user.name "Greedys CI Bot"

  script:
    - echo "‚è≥ Attendo che l'API sia pronta..."
    - sleep 120
    
    # Test connessione API
    - |
      for i in {1..30}; do
        echo "Tentativo $i/30: Testing ${API_DOCS_BASE}/restaurant-api"
        if curl -f --max-time 15 "${API_DOCS_BASE}/restaurant-api" >/dev/null 2>&1; then
          echo "‚úÖ API docs pronte!"
          break
        fi
        sleep 10
        if [ $i -eq 30 ]; then
          echo "‚ùå TIMEOUT: API non risponde"
          exit 1
        fi
      done
    
    - echo "Pulisco cartelle client API precedenti..."
    - rm -rf restaurant admin customer

    # GENERA CLIENT PER OGNI GRUPPO
    - |
      for GROUP in $API_GROUPS; do
        SPEC_FILE="./openapi-${GROUP}.json"
        OUTPUT_DIR="./${GROUP}_api"

        echo ""
        echo "üéØ >>> Generazione client $GROUP <<<"
        
        # Scarica spec OpenAPI
        echo "üì• Scarico spec da ${API_DOCS_BASE}/${GROUP}-api"
        if curl -sSfk -o "$SPEC_FILE" "${API_DOCS_BASE}/${GROUP}-api"; then
          echo "‚úÖ Spec scaricata: $(wc -c < "$SPEC_FILE") bytes"
        else
          echo "‚ùå ERRORE: Impossibile scaricare spec per $GROUP"
          exit 1
        fi

        # Scarica response wrappers per questo gruppo (FORMATO CORRETTO come script test)
        echo "üì• Scarico response wrappers per $GROUP..."
        WRAPPERS_FILE="response-wrappers-${GROUP}.json"
        WRAPPERS_SERVER_FILE="response-wrappers-${GROUP}-server.json"
        
        if curl -sSfk "$WRAPPERS_ENDPOINT/${GROUP}" -o "$WRAPPERS_SERVER_FILE"; then
          # Verifica se il download √® valido (contiene il campo .value)
          if jq -e '.value' "$WRAPPERS_SERVER_FILE" >/dev/null 2>&1; then
            echo "‚úÖ Wrappers scaricati dal server ($(stat -c%s "$WRAPPERS_SERVER_FILE") bytes)"
            
            # ESTRAI IL CONTENUTO DA .value E SALVALO NEL FILE FINALE
            # Il server restituisce: {"value": "{\"generatedAt\":\"...\",\"entries\":[...]}"}
            # Dobbiamo estrarre .value e parsarlo come JSON
            if jq -r '.value | fromjson' "$WRAPPERS_SERVER_FILE" > "$WRAPPERS_FILE" 2>/dev/null; then
              echo "‚úÖ Catalogo estratto correttamente da .value ($(stat -c%s "$WRAPPERS_FILE") bytes)"
              
              # Mostra alcuni wrapper dal catalogo per debug
              WRAPPER_COUNT=$(jq -r '.entries | length' "$WRAPPERS_FILE" 2>/dev/null || echo "0")
              WRAPPER_NAMES=$(jq -r '.entries[].wrapper' "$WRAPPERS_FILE" 2>/dev/null | head -3 | tr '\n' ',' | sed 's/,$//' || echo "nessuno")
              echo "üìã Catalogo $GROUP: $WRAPPER_COUNT wrappers totali"
              echo "üìã Primi 3 wrapper: $WRAPPER_NAMES"
              
              # Mostra anche generatedAt per verificare la freschezza del catalogo
              GENERATED_AT=$(jq -r '.generatedAt' "$WRAPPERS_FILE" 2>/dev/null || echo "sconosciuto")
              echo "üìÖ Catalogo generato il: $GENERATED_AT"
            else
              echo "‚ùå Errore nell'estrazione di .value, uso catalogo vuoto"
              echo '{"generatedAt":"'$(date -Iseconds)'","entries":[]}' > "$WRAPPERS_FILE"
            fi
            
            # Cleanup file temporaneo server
            rm -f "$WRAPPERS_SERVER_FILE"
          else
            echo "‚ùå Server restituisce errore per $GROUP (no .value field), uso catalogo vuoto"
            echo "   Contenuto risposta server:"
            cat "$WRAPPERS_SERVER_FILE" | head -3 | sed 's/^/   /' || echo "   File vuoto"
            echo '{"generatedAt":"'$(date -Iseconds)'","entries":[]}' > "$WRAPPERS_FILE"
            rm -f "$WRAPPERS_SERVER_FILE"
          fi
        else
          echo "‚ùå Catalogo wrappers non disponibile per $GROUP (curl failed), uso catalogo vuoto"
          echo '{"generatedAt":"'$(date -Iseconds)'","entries":[]}' > "$WRAPPERS_FILE"
        fi
        
        echo "üìã Response wrappers file: $(ls -la response-wrappers-${GROUP}.json 2>/dev/null || echo 'File non trovato')"
        
        # DEBUG: Verifica posizione corrente e struttura directory
        echo "üîç DEBUG: Verifica struttura directory e files..."
        echo "   Current directory: $(pwd)"
        echo "   Parent directory contents:"
        ls -la ../ 2>/dev/null | head -10 || echo "   Directory parent inaccessibile"
        
        # Verifica che i template e ignore file esistano 
        TEMPLATES_DIR="../generator/templates"
        echo "   Verifica templates dir: $TEMPLATES_DIR"
        
        if [ -d "$TEMPLATES_DIR" ]; then
          echo "‚úÖ Directory templates trovata"
          echo "   Templates directory contents:"
          ls -la "$TEMPLATES_DIR" 2>/dev/null | head -10 || echo "   Directory templates inaccessibile"
          
          # Verifica se il file .openapi-generator-ignore esiste (scaricato dal Package Registry)
          IGNORE_FILE="$TEMPLATES_DIR/.openapi-generator-ignore"
          
          if [ -f "$IGNORE_FILE" ] && [ -s "$IGNORE_FILE" ]; then
            echo "‚úÖ File .openapi-generator-ignore trovato dal Package Registry"
            echo "   Dimensione: $(stat -c%s "$IGNORE_FILE") bytes"
            echo "   Numero righe: $(wc -l < "$IGNORE_FILE")"
            echo "   Contenuto ignore file (prime righe):"
            head -5 "$IGNORE_FILE" 2>/dev/null | sed 's/^/     /' || echo "     File vuoto"
          else
            echo "‚ö†Ô∏è File .openapi-generator-ignore non trovato o vuoto, creo fallback"
            echo "üìã Creo ignore file fallback con contenuto corretto per filtering ResponseWrapper..."
            # Creo il file ignore con echo per evitare problemi YAML heredoc
            echo "# If you want to also avoid committing generated client entirely, prefer using .gitignore" > "$IGNORE_FILE"
            echo "" >> "$IGNORE_FILE"
            echo "# Ignore all generated response_wrapper* model files (catch-all)" >> "$IGNORE_FILE"
            echo "# EXCEPT ResponseWrapperErrorDetails which is needed for error handling" >> "$IGNORE_FILE"
            echo "lib/**/model/response_wrapper*.*" >> "$IGNORE_FILE"
            echo "lib/**/model/*response_wrapper*.dart" >> "$IGNORE_FILE"
            echo "lib/**/model/*response_wrapper*.*" >> "$IGNORE_FILE"
            echo "**/model/response_wrapper*.*" >> "$IGNORE_FILE"
            echo "" >> "$IGNORE_FILE"
            echo "# Allow ResponseWrapperErrorDetails specifically" >> "$IGNORE_FILE"
            echo "!lib/**/model/response_wrapper_error_details.*" >> "$IGNORE_FILE"
            echo "!lib/**/model/response_wrapper_error_details.dart" >> "$IGNORE_FILE"
            echo "!**/model/response_wrapper_error_details.*" >> "$IGNORE_FILE"
            echo "!**/model/response_wrapper_error_details.dart" >> "$IGNORE_FILE"
            echo "" >> "$IGNORE_FILE"
            echo "# Ignore response_wrapper documentation files" >> "$IGNORE_FILE"
            echo "# EXCEPT ResponseWrapperErrorDetails docs" >> "$IGNORE_FILE"
            echo "doc/ResponseWrapper*.md" >> "$IGNORE_FILE"
            echo "doc/*ResponseWrapper*.md" >> "$IGNORE_FILE"
            echo "!doc/ResponseWrapperErrorDetails.md" >> "$IGNORE_FILE"
            echo "" >> "$IGNORE_FILE"
            echo "# Ignore response_wrapper test files" >> "$IGNORE_FILE"
            echo "# EXCEPT ResponseWrapperErrorDetails tests" >> "$IGNORE_FILE"
            echo "test/response_wrapper*.dart" >> "$IGNORE_FILE"
            echo "test/*response_wrapper*.dart" >> "$IGNORE_FILE"
            echo "!test/response_wrapper_error_details*.dart" >> "$IGNORE_FILE"
            echo "   Creato ignore file fallback con $(wc -l < "$IGNORE_FILE") righe di regole"
          fi
        else
          echo "‚ùå Directory templates NON trovata: $TEMPLATES_DIR"
          echo "üìã Creo directory e ignore file fallback..."
          mkdir -p "$TEMPLATES_DIR"
          IGNORE_FILE="$TEMPLATES_DIR/.openapi-generator-ignore"
          # Creo il file ignore fallback
          echo "# If you want to also avoid committing generated client entirely, prefer using .gitignore" > "$IGNORE_FILE"
          echo "" >> "$IGNORE_FILE"
          echo "# Ignore all generated response_wrapper* model files (catch-all)" >> "$IGNORE_FILE"
          echo "lib/**/model/response_wrapper*.*" >> "$IGNORE_FILE"
          echo "**/model/response_wrapper*.*" >> "$IGNORE_FILE"
          echo "doc/ResponseWrapper*.md" >> "$IGNORE_FILE"
          echo "test/response_wrapper*.dart" >> "$IGNORE_FILE"
          echo "" >> "$IGNORE_FILE"
          echo "# Allow ResponseWrapperErrorDetails specifically" >> "$IGNORE_FILE"
          echo "!lib/**/model/response_wrapper_error_details.*" >> "$IGNORE_FILE"
          echo "!doc/ResponseWrapperErrorDetails.md" >> "$IGNORE_FILE"
          echo "!test/response_wrapper_error_details*.dart" >> "$IGNORE_FILE"
          echo "   Creati: $TEMPLATES_DIR e ignore file fallback con $(wc -l < "$IGNORE_FILE") righe di regole"
        fi
        
        # VERIFICA FINALE del contenuto ignore file
        echo ""
        echo "üß™ VERIFICA FINALE ignore file..."
        if [ -f "$IGNORE_FILE" ]; then
          echo "   ‚úÖ File esiste: $IGNORE_FILE"
          echo "   üìä Dimensione: $(stat -c%s "$IGNORE_FILE") bytes, Righe: $(wc -l < "$IGNORE_FILE")"
          
          # Verifica rapida delle regole essenziali
          if grep -q "response_wrapper" "$IGNORE_FILE" 2>/dev/null; then
            echo "   ‚úÖ Contiene regole ResponseWrapper filtering"
            
            # Conta le regole principali
            IGNORE_RULES=$(grep -c "response_wrapper" "$IGNORE_FILE" 2>/dev/null || echo "0")
            ALLOW_RULES=$(grep -c "!.*response_wrapper_error_details" "$IGNORE_FILE" 2>/dev/null || echo "0")
            echo "   üìã Regole ignore: $IGNORE_RULES, Eccezioni allow: $ALLOW_RULES"
            
          else
            echo "   ‚ö†Ô∏è File ignore senza regole ResponseWrapper, potrebbe essere vuoto"
          fi
          
          # Mostra un campione del contenuto per debug
          echo "   üìÑ Contenuto ignore file (prime 10 righe):"
          head -10 "$IGNORE_FILE" 2>/dev/null | sed 's/^/      /' || echo "      File vuoto o inaccessibile"
        else
          echo "   ‚ùå ERRORE: File ignore non esiste!"
          exit 1
        fi

        # GENERA CON CUSTOM GENERATOR v1.0.0-SNAPSHOT STANDALONE
        echo "üîß Genero client con custom generator v1.0.0-SNAPSHOT..."
        echo "   Debug: Usando JAR = $CUSTOM_JAR"
        
        # GENERA CON CUSTOM GENERATOR (COME SCRIPT TEST FUNZIONANTE)
        echo "üîß Genero client con custom generator (formato script test)..."
        JAVA_CMD="java -jar $CUSTOM_JAR generate \
          -g org.openapitools.custom.CustomDartClientCodegen \
          -i $SPEC_FILE \
          -o $OUTPUT_DIR \
          -t $TEMPLATES_DIR \
          --ignore-file-override $IGNORE_FILE \
          --skip-validate-spec \
          -p pubName=${GROUP}_api \
          -p pubVersion=1.0.0 \
          -p pubDescription=\"Greedys ${GROUP^} API client\" \
          -p pubHomepage=https://greedys.it"
        
        echo "Command: $JAVA_CMD"
        if eval $JAVA_CMD; then
          echo "‚úÖ Generazione completata con successo"
        else
          echo "‚ö†Ô∏è Tentativo principale fallito, provo fallback java -cp..."
          JAVA_FALLBACK_CMD="java -cp $CUSTOM_JAR org.openapitools.codegen.OpenAPIGenerator generate \
            -g org.openapitools.custom.CustomDartClientCodegen \
            -i $SPEC_FILE \
            -o $OUTPUT_DIR \
            -t $TEMPLATES_DIR \
            --ignore-file-override $IGNORE_FILE \
            --skip-validate-spec \
            -p pubName=${GROUP}_api \
            -p pubVersion=1.0.0 \
            -p pubDescription=\"Greedys ${GROUP^} API client\" \
            -p pubHomepage=https://greedys.it"
          
          echo "Fallback command: $JAVA_FALLBACK_CMD"
          if eval $JAVA_FALLBACK_CMD; then
            echo "‚úÖ Generazione completata con fallback java -cp"
          else
            echo "‚ùå ERRORE: Entrambi i metodi falliti"
            echo "   Debug MANIFEST.MF:"
            unzip -p "$CUSTOM_JAR" META-INF/MANIFEST.MF | head -5 || echo "   MANIFEST.MF inaccessibile"
            echo "   Debug JAR structure:"
            unzip -l "$CUSTOM_JAR" | grep -E "(Main-Class|org/openapitools)" | head -5 || echo "   Struttura JAR problematica"
            exit 1
          fi
        fi

        # ANALISI RISULTATI (COME SCRIPT TEST per verificare filtering)
        echo ""
        echo "üìä ANALISI RISULTATI per $GROUP"
        
        # Controlla serializers.dart
        SERIALIZERS_FILE="$OUTPUT_DIR/lib/src/serializers.dart"
        if [ -f "$SERIALIZERS_FILE" ]; then
          RESPONSE_WRAPPERS=$(grep -o 'ResponseWrapper[A-Za-z0-9]*' "$SERIALIZERS_FILE" 2>/dev/null | sort -u || true)
          WRAPPER_COUNT=$(echo "$RESPONSE_WRAPPERS" | wc -l)
          
          echo "üîç ResponseWrapper trovati in serializers.dart ($WRAPPER_COUNT):"
          
          if [ -n "$RESPONSE_WRAPPERS" ] && [ "$RESPONSE_WRAPPERS" != "" ]; then
            # Ottieni tutti i wrapper dal catalogo (formato server)
            ALL_CATALOG_WRAPPERS=$(jq -r '.value | fromjson | .entries[].wrapper' "$WRAPPERS_FILE" 2>/dev/null || true)
            
            while IFS= read -r wrapper; do
              if [ -n "$wrapper" ]; then
                if echo "$ALL_CATALOG_WRAPPERS" | grep -q "^$wrapper$"; then
                  echo "   $wrapper - ‚ùå NEL CATALOGO (dovrebbe essere filtrato)"
                else
                  echo "   $wrapper - ‚úÖ NON nel catalogo (OK)"
                fi
              fi
            done <<< "$RESPONSE_WRAPPERS"
          else
            echo "   ‚úÖ Nessun ResponseWrapper trovato (filtering perfetto)"
          fi
        else
          echo "‚ùå File serializers.dart non trovato!"
        fi
        
        # Controlla modelli generati
        MODELS_DIR="$OUTPUT_DIR/lib/src/model"
        if [ -d "$MODELS_DIR" ]; then
          MODEL_FILES=$(find "$MODELS_DIR" -name "response_wrapper*.dart" 2>/dev/null || true)
          MODEL_COUNT=$(echo "$MODEL_FILES" | wc -l)
          
          echo "üîç File modelli ResponseWrapper generati ($MODEL_COUNT):"
          
          if [ -n "$MODEL_FILES" ] && [ "$MODEL_FILES" != "" ]; then
            # Ottieni tutti i wrapper dal catalogo (formato server)
            ALL_CATALOG_WRAPPERS=$(jq -r '.value | fromjson | .entries[].wrapper' "$WRAPPERS_FILE" 2>/dev/null || true)
            
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                filename=$(basename "$file")
                # Converti il nome del file nel nome del modello
                model_name=$(echo "$filename" | sed 's/\.dart$//' | sed 's/_//g' | sed 's/responsewrapper/ResponseWrapper/')
                
                if echo "$ALL_CATALOG_WRAPPERS" | grep -q "^$model_name$"; then
                  echo "   $filename -> $model_name - ‚ùå NEL CATALOGO (dovrebbe essere filtrato)"
                else
                  echo "   $filename -> $model_name - ‚úÖ NON nel catalogo (OK)"
                fi
              fi
            done <<< "$MODEL_FILES"
          else
            echo "   ‚úÖ Nessun file modello ResponseWrapper trovato (filtering perfetto)"
          fi
        else
          echo "‚ùå Directory modelli non trovata: $MODELS_DIR"
        fi

        # POST-PROCESSING CLEANUP (solo se necessario dopo analisi)
        echo ""
        echo "üßπ Post-processing cleanup per $GROUP..."
        
        # Rimuovi doc ResponseWrapper indesiderati
        [ -d "$OUTPUT_DIR/doc" ] && find "$OUTPUT_DIR/doc" -name "ResponseWrapper*.md" ! -name "ResponseWrapperErrorDetails.md" -delete 2>/dev/null || true
        
        # Rimuovi test ResponseWrapper indesiderati  
        [ -d "$OUTPUT_DIR/test" ] && find "$OUTPUT_DIR/test" -name "response_wrapper*.dart" ! -name "response_wrapper_error_details_test.dart" -delete 2>/dev/null || true
        
        # Pulisci import ResponseWrapper generati automaticamente
        [ -d "$OUTPUT_DIR/lib" ] && find "$OUTPUT_DIR/lib" -name "*.dart" -exec sed -i "/^import 'package:${GROUP}_api\/.*\/response_wrapper.*';$/d" {} \; 2>/dev/null || true
        
        # Aggiorna pubspec.yaml con common
        PUBSPEC="$OUTPUT_DIR/pubspec.yaml"
        if [ -f "$PUBSPEC" ] && ! grep -q "common:" "$PUBSPEC"; then
          echo "  common:" >> "$PUBSPEC"
          echo "    path: ../common" >> "$PUBSPEC"
        fi
        
        # Pulisci export ResponseWrapper da openapi.dart
        OPENAPI_FILE="$OUTPUT_DIR/lib/openapi.dart"
        [ -f "$OPENAPI_FILE" ] && sed -i "/^export 'package:.*\/response_wrapper\([^_]\|_[^e]\)/d" "$OPENAPI_FILE" 2>/dev/null || true

        rm "$SPEC_FILE"
        echo "‚úÖ Client $GROUP generato con successo!"
      done

    # COMMIT E PUSH
    - echo ""
    - echo "üì§ Commit e push delle modifiche..."
    - git add .
    - |
      if git diff-index --quiet HEAD; then
        echo "üìù Nessuna modifica da pushare"
      else
        git commit -m "ü§ñ Genera Dart clients v1.0.0-SNAPSHOT: $API_GROUPS"
        git push origin main
        echo "‚úÖ Client v1.0.0-SNAPSHOT pushati con successo!"
      fi

  only:
    - main